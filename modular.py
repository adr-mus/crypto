import math
from itertools import count, product

import numpy as np

from numth import carmichael, divisors, factorize, lcm, phi


def inverse(a, n):
    """ Returns the solution of the congruence ax = 1 (mod n). """
    if math.gcd(a, n) != 1:
        raise ValueError(f"a and n must be relatively prime.")

    a %= n
    if a in [1, n - 1]:
        return a

    return pow(a, carmichael(n) - 1, n)


def order(a, n):
    """ Computes order of a modulo n. """
    return min(d for d in divisors(carmichael(n)) if pow(a, d, n) == 1)


def powers(a, n):
    """ Generates all the elements in the subgroup of Z_n generated by a. """
    for k in count(1):
        p = pow(a, k, n)
        yield p
        if p == 1:
            break


def solve_cong(a, b, n):
    """ Solves the congruence ax = b (mod n) and returns a pair c, m 
        such that x = c (mod m) or None if there are no solutions. """
    a %= n
    b %= n
    if a != 0:
        gcd = math.gcd(a, n)
        if b % gcd != 0:
            return
        a //= gcd
        b //= gcd
        n //= gcd
        return inverse(a, n) * b % n, n
    elif b == 0:
        return 0, 1


def solve_mult_cong(equations):
    """ Takes an iterable of pairs of form (remainder, modulus). 
        Solves the multiple congruence x = eq[i][0] (mod eq[i][1])
        assuming the moduli are relatively prime. 
        Returns a pair R, M such that x = R (mod M). """
    equations = iter(equations)
    R, M = next(equations)
    for r, m in equations:
        r1 = inverse(M, m) * (r - R) % m
        R = M * r1 + R
        M *= m
        R %= M

    return R, M


def pow_mod(a, e, n):
    """ Computes a^e mod n using Carmichael's function. """
    fact = factorize(n)
    rems, mods = [], []
    for p, exp in fact:
        d = p ** exp
        mods.append(d)
        if a % p == 0 and e > exp:
            rems.append(0)
        else:
            rems.append(pow(a % d, e % carmichael(d), d))
            
    if len(rems) > 1:
        R = solve_mult_cong(zip(rems, mods))[0]
    else:
        R = rems[0]

    return R


def det(A, p):
    """ Computes the determinant of A modulo p assuming A is a matrix of ints. """
    return int(round(np.linalg.det(A))) % p


def mat_inverse(A, p):
    """ Inverts the matrix A modulo p assuming A is a matrix of ints. """
    det_A_num = np.linalg.det(A)
    if det_A_num == 0:
        raise ZeroDivisionError("det(A) = 0 (mod p)")
    det_A_inv = inverse(int(round(det_A_num)), p)
    return det_A_inv * np.round(det_A_num * np.linalg.inv(A)).astype(int) % p


def _primitive_root(p):
    """ For internal use only - see primitive_root() for other purposes.
        Finds a primitive root modulo p using Gauss's algorithm
        assuming p is prime. """
    a = 2
    ps = set(powers(a, p))
    t = len(ps)
    if t == p - 1:
        return a

    while True:
        for b in count(1):
            if b not in ps:
                break
        u = order(b, p)
        if u == p - 1:
            return b

        v = lcm(t, u)
        (v1, v2) = (t, v // t) if t > u else (v // u, u)
        g = pow(a, t // v1, p) * pow(b, u // v2, p) % p
        if v == p - 1:
            return g

        a, t = g, v
        ps = set(powers(g, p))


def primitive_root(n):
    """ Finds a primitive root modulo n using Gauss's algorithm
        and some related facts. """
    fact = factorize(n)
    if len(fact) == 1:
        p, e = fact[0]
        if p == 2:
            if e <= 2:
                return n // 2
            return

        pr = _primitive_root(p)
        if e > 1 and pow(pr, p - 1, p ** 2) == 1:
            pr += p
        return pr
    elif len(fact) == 2:
        if fact[0] != (2, 1):
            return

        p, e = fact[1]
        pr = _primitive_root(p)
        if e > 1 and pow(pr, p - 1, p ** 2) == 1:
            pr += p
        if pr % 2 == 0:
            pr += p ** e
        return pr


def _log_shanks(g, a, p):
    """ For internal use only - see log() for other purposes.
        Finds the discreet logarithm log_g(a) modulo p using
        Shanks's algorithm. """
    phi_p = p - 1
    m = int(phi_p ** 0.5) + 1
    g_inv = inverse(g, p)
    baby_steps = [pow(g, i, p) for i in range(m + 1)]
    for j in range(m + 1):
        giant_step = a * pow(g_inv, j * m, p) % p
        if giant_step in baby_steps:
            return (baby_steps.index(giant_step) + j * m) % phi_p


def _log_pohlig_hellman_pp(g, a, p, q, e):
    """ For internal use only - see log() for other purposes.
        Auxiliary function in the Pohlig-Hellman algorithm below.  """

    # the first congruence
    ng = pow(g, q ** (e - 1), p)
    na = pow(a, q ** (e - 1), p)
    for j in range(q):
        if pow(ng, j, p) == na:
            break
    x = [j]

    # all the other congruences
    g_inv = inverse(g, p)
    for i in range(e - 2, -1, -1):
        exp = sum(x[j] * q ** j for j in range(len(x)))
        na = pow(a * pow(g_inv, exp, p), q ** i, p)
        for j in range(p):
            if pow(ng, j, p) == na:
                break
        x.append(j)

    return sum(x[j] * q ** j for j in range(len(x)))


def _log_pohlig_hellman(g, a, p):
    """ For internal use only - see log() for other purposes.
        Finds the discreet logarithm log_g(a) modulo p using the 
        Pohlig-Hellman algorithm. """
    o = order(g, p)
    fact = factorize(o)
    rems, mods = [], []
    for q, e in fact:
        d = q ** e
        ne = o // d
        rem = _log_pohlig_hellman_pp(pow(g, ne, p), pow(a, ne, p), p, q, e)
        rems.append(rem)
        mods.append(d)

    return solve_mult_cong(zip(rems, mods))[0]


def _log_rho(g, a, p, *, partition="d"):
    """ For internal use only - see log() for other purposes.
        Finds the discreet logarithm log_g(a) modulo p using 
        Pollard's rho algorithm. """
    phi_p = phi(p)
    for i, j in product(range(phi_p), repeat=2):
        u, v = [i], [j]
        x = [a ** u[0] * g ** v[0] % p]
        for i in count(1):
            if partition == "d":
                r = x[-1]
                if r < p // 3:
                    x.append(x[-1] ** 2 % p)
                    u.append(2 * u[-1] % phi_p)
                    v.append(2 * v[-1] % phi_p)
                elif r < 2 * p // 3:
                    x.append(a * x[-1] % p)
                    u.append((u[-1] + 1) % phi_p)
                    v.append(v[-1])
                else:
                    x.append(g * x[-1] % p)
                    u.append(u[-1])
                    v.append((v[-1] + 1) % phi_p)
            elif partition == "m":
                r = x[-1] % 3
                if r == 0:
                    x.append(x[-1] ** 2 % p)
                    u.append(2 * u[-1] % phi_p)
                    v.append(2 * v[-1] % phi_p)
                elif r == 1:
                    x.append(a * x[-1] % p)
                    u.append((u[-1] + 1) % phi_p)
                    v.append(v[-1])
                else:
                    x.append(g * x[-1] % p)
                    u.append(u[-1])
                    v.append((v[-1] + 1) % phi_p)

            if i % 2 == 0 and x[i] == x[i // 2]:
                break

        b, c = u[i // 2] - u[i], v[i] - v[i // 2]
        if (b - c) % p != 0:
            log = solve_cong(b, c, phi_p)
            if log is not None and log[1] == phi_p:
                return log[0]
    
    raise ValueError("Other partition is needed.")


def log(g, a, p, method="ph"):
    """ Computes the discreet logarithm log_g(a) modulo p using
        one of the following methods:
            "sh" - Shanks's baby-steps giant-steps algorithm,
            "ph" - the Pohlig-Hellman algorithm (default),
            "rho" - Pollard's rho algorithm. """
    if method == "ph":
        return _log_pohlig_hellman(g, a, p)
    elif method == "sh":
        return _log_shanks(g, a, p)
    elif method == "rho":
        return _log_rho(g, a, p)
    else:
        raise ValueError(f"Invalid method: {method}")


def _root_p2(n, a, e):
    """ For internal use only - see root() for other purposes.
        Finds the solutions of the equation x^n = a (mod 2^e) where e > 2
        assuming a is invertible modulo 2^e. """
    m = 2 ** e
    a %= m
    phi_m = 2 ** (e - 2)
    if pow(a, phi_m // math.gcd(n, phi_m), m) != 1:
        return

    if a % 8 in [1, 3]:
        i, j = 0, _log_shanks(3, a, m)
    else:
        i, j = 1, _log_shanks(3, m - a, m)
    k, l = solve_cong(n, i, 2), solve_cong(n, j, phi_m)
    ks = [k[0] + i * k[1] for i in range(math.ceil((2 - k[0]) / k[1]))]
    ls = [l[0] + i * l[1] for i in range(math.ceil((phi_m - l[0]) / l[1]))]

    return [pow(-1, k, m) * pow(3, l, m) % m for k in ks for l in ls]


def _root_pp(n, a, q, e):
    """ For internal use only - see root() for other purposes.
        Finds the solutions of the equation x^n = a (mod q^e) under the 
        assumption that q is an odd prime number or q^e = 2 or q^e = 4. """
    m = q ** e
    a %= m
    phi_m = m - q ** (e - 1)
    gcd = math.gcd(n, phi_m)
    if pow(a, phi_m // gcd, m) != 1:
        return

    g = primitive_root(m)
    log = _log_shanks(g, a, m)
    rem = solve_cong(n, log, phi_m)
    log_rems = [rem[0] + i * rem[1] for i in range(gcd)]

    return [pow(g, rem, m) for rem in log_rems]


def root(n, a, m):
    """ Finds the solutions of the equation x^n = a (mod m). """
    rems, mods = [], []
    for q, e in factorize(m):
        if q == 2 and e > 2:
            r = _root_p2(n, a, e)
        else:
            r = _root_pp(n, a, q, e)
        if r is None:
            return
        rems.append(r)
        mods.append(q ** e)

    if len(rems) > 1:
        sols = [solve_mult_cong(zip(rs, mods))[0] for rs in product(*rems)]
    else:
        sols = rems[0]

    return sols


def jacobi(a, n):
    """ Computes the Jacobi symbol (a|n). """
    a %= n
    if a in [0, 1]:
        return a

    Rs, es = [a, n], [0]
    while Rs[-1] != 1:
        R = Rs[-2] % Rs[-1]
        e = 0
        while R % 2 == 0:
            R //= 2
            e += 1
        Rs.append(R)
        es.append(e)

    m = len(Rs) - 1
    A1 = sum(((Rs[i] ** 2 - 1) // 8) % 2 for i in range(1, m) if es[i] % 2 != 0)
    A2 = sum(((Rs[i] - 1) * (Rs[i + 1] - 1) // 4) % 2 for i in range(1, m - 1))

    return (-1) ** (A1 + A2)


def sq_root(a, p):
    """ Finds the solutions of the congruence X^2 = a (mod p), where p is 
        prime, using the Tonelli-Shanks algorithm.
        For more general cases, see root() or solve_quadr(). """
    jac = jacobi(a, p)
    if jac == 0:
        return [0, 0]
    if jac == -1:
        return

    if p % 8 in [3, 7]:
        x = pow(a, (p + 1) // 4, p)
    if p % 8 == 5:
        x = pow(a, (p + 3) // 8, p)
        if pow(x, 2, p) != a:
            x = x * pow(2, (p - 1) // 4, p) % p
    elif p % 8 == 1:
        r = 0
        s = p - 1
        while s % 2 == 0:
            s //= 2
            r += 1

        for d in count(2):
            if jacobi(d, p) == -1:
                break
        D = pow(d, s, p)
        a_inv = inverse(a, p)

        x = pow(a, (s + 1) // 2, p)
        t = round(math.log2(order(pow(x, 2, p) * a_inv, p)))
        while t != 0:
            x = x * pow(D, 2 ** (r - t - 1), p) % p
            t = round(math.log2(order(pow(x, 2, p) * a_inv, p)))

    return [x, p - x]


def _solve_quadr_p(a, b, c, p):
    """ For internal use only - see solve_quadr() for other purposes.
        Finds the solutions of the congruence aX^2 + bX + c = 0 (mod p)
        where p is prime. """
    a %= p
    b %= p
    c %= p

    if a == 0:
        if b == 0:
            if c == 0:
                return list(range(p))
            return
        r, m = solve_cong(b, -c, p)
        return list(i * p + r for i in range(p // m))

    if p == 2:
        return [i for i in range(2) if (a * i ** 2 + b * i + c) % 2 == 0]

    sq_D = sq_root(b ** 2 - 4 * a * c, p)
    if not sq_D:
        return

    da_inv = inverse(2 * a, p)
    return [(-b + sq_D[0]) * da_inv % p, (-b + sq_D[1]) * da_inv % p]


def _solve_quadr_pk(a, b, c, p, k):
    """ For internal use only - see solve_quadr() for other purposes.
        Finds the solutions of the congruence aX^2 + bX + c = 0 (mod p^k),
        where p is prime. """
    roots = _solve_quadr_p(a, b, c, p)
    f = lambda x: a * x ** 2 + b * x + c
    f_d = lambda x: 2 * a * x + b
    for i in range(1, k):
        if not roots:
            break
        new_roots = []
        for r in roots:
            if math.gcd(p, f_d(r)) == 1:
                u = solve_cong(p ** i * f_d(r), -f(r), p ** (i + 1))[0]
                new_roots.append(r + u * p ** i)
            elif f(r) % p ** (i + 1) == 0:
                new_roots.extend(r + p ** i * j for j in range(p))
        roots = new_roots

    return roots


def solve_quadr(a, b, c, n):
    """ Finds the solutions of the congruence aX^2 + bX + c = 0 (mod n). """
    rems, mods = [], []
    for q, e in factorize(n):
        rem = _solve_quadr_pk(a, b, c, q, e)
        if not rem:
            rems = []
            break
        rems.append(rem)
        mods.append(q ** e)

    if len(rems) > 1:
        sols = [solve_mult_cong(zip(rs, mods))[0] for rs in product(*rems)]
    elif len(rems) == 1:
        sols = rems[0]
    else:
        sols = []

    return sols
